#!/usr/bin/env bash
# serial-snapshot - Capture time-limited snapshot of serial output
#
# Usage: ./scripts/serial-snapshot [OPTIONS]
#
# Options:
#   --port <path>    Serial port path (default: auto-detect)
#   --baud <rate>    Baud rate (default: 115200)
#   --seconds <N>    Capture duration (default: 5)
#   --lines <N>      Stop after N lines (0 = use seconds)
#   --quiet          Output only captured data, no header
#
# Exit codes:
#   0 - Boot output detected (contains rst: or boot:)
#   1 - No boot output detected
#   2 - Port error
#
# Environment:
#   UPLOAD_PORT   Override port
#   BAUD_RATE     Override baud rate

set -euo pipefail

# --- Configuration ---
VERSION="1.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# --- Globals ---
PORT=""
BAUD="${BAUD_RATE:-115200}"
SECONDS_LIMIT=5
LINES_LIMIT=0
QUIET=false

# --- Functions ---

usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Capture a time-limited snapshot of serial output for boot verification.

Options:
  --port <path>    Serial port path (default: auto-detect)
  --baud <rate>    Baud rate (default: 115200)
  --seconds <N>    Capture duration in seconds (default: 5)
  --lines <N>      Stop after N lines (0 = use seconds, default: 0)
  --quiet          Output only captured data, no header
  -h, --help       Show this help message
  -v, --version    Show version

Exit codes:
  0 - Boot output detected (contains 'rst:' or 'boot:')
  1 - No boot output detected (may be stuck in download mode)
  2 - Port error

Environment:
  UPLOAD_PORT    Override port
  BAUD_RATE      Override baud rate
EOF
}

# Get port from device-list
get_auto_port() {
    local device_list_script="$SCRIPT_DIR/device-list"
    
    if [[ -x "$device_list_script" ]]; then
        "$device_list_script" --first 2>/dev/null || echo ""
    else
        pio device list 2>/dev/null | grep -E '^/dev/' | head -1 || echo ""
    fi
}

# Main function
main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --port)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --port requires a path" >&2
                    exit 1
                fi
                PORT="$2"
                shift 2
                ;;
            --baud)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --baud requires a number" >&2
                    exit 1
                fi
                BAUD="$2"
                shift 2
                ;;
            --seconds)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --seconds requires a number" >&2
                    exit 1
                fi
                SECONDS_LIMIT="$2"
                shift 2
                ;;
            --lines)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --lines requires a number" >&2
                    exit 1
                fi
                LINES_LIMIT="$2"
                shift 2
                ;;
            --quiet)
                QUIET=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                echo "serial-snapshot version $VERSION"
                exit 0
                ;;
            *)
                echo "Error: Unknown option: $1" >&2
                usage >&2
                exit 1
                ;;
        esac
    done
    
    # Get port (env override, then argument, then auto-detect)
    PORT="${UPLOAD_PORT:-$PORT}"
    
    if [[ -z "$PORT" ]]; then
        PORT=$(get_auto_port)
    fi
    
    if [[ -z "$PORT" ]]; then
        echo "Error: No serial port found" >&2
        exit 2
    fi
    
    # Verify port exists
    if [[ ! -e "$PORT" ]]; then
        echo "Error: Port $PORT does not exist" >&2
        exit 2
    fi
    
    # Check permissions
    if [[ ! -r "$PORT" || ! -w "$PORT" ]]; then
        echo "Error: Permission denied on $PORT" >&2
        exit 2
    fi
    
    # Print header (unless quiet)
    local start_time
    start_time=$(date '+%Y-%m-%d %H:%M:%S')
    
    if ! $QUIET; then
        echo "=== Serial Snapshot (${SECONDS_LIMIT} seconds) ==="
        echo "Port: $PORT"
        echo "Baud: $BAUD"
        echo "Start: $start_time"
        echo "---"
    fi
    
    # Capture serial output with Python
    local output=""
    local boot_detected=false
    local line_count=0
    local actual_duration=0
    
    output=$(python3 << EOF 2>/dev/null || true
import serial
import time
import sys

try:
    ser = serial.Serial('$PORT', $BAUD, timeout=0.5)
    
    start = time.time()
    lines = 0
    max_lines = $LINES_LIMIT
    max_seconds = $SECONDS_LIMIT
    
    while True:
        # Check time limit
        elapsed = time.time() - start
        if max_seconds > 0 and elapsed >= max_seconds:
            break
        
        # Read data
        try:
            data = ser.read(1024)
            if data:
                text = data.decode('utf-8', errors='replace')
                print(text, end='', flush=True)
                
                # Count lines
                lines += text.count('\n')
                
                # Check line limit
                if max_lines > 0 and lines >= max_lines:
                    break
        except:
            pass
    
    ser.close()
    
    # Output duration for parent script
    print("\n__DURATION__:{:.1f}".format(time.time() - start), file=sys.stderr)
    print("__LINES__:{}".format(lines), file=sys.stderr)
    
except Exception as e:
    print(f"Error: {e}", file=sys.stderr)
    sys.exit(2)
EOF
)
    local capture_exit=$?
    
    # Print captured output
    echo "$output"
    
    # Extract metrics from stderr (captured in output with redirection)
    # Note: This is simplified - actual metrics parsing would need stderr capture
    
    if ! $QUIET; then
        echo "---"
        echo "=== End Snapshot ==="
    fi
    
    # Check for boot signatures
    if echo "$output" | grep -qiE '(rst:|boot:|esp-idf|wifi|setup\(\)|loop\(\))'; then
        boot_detected=true
    fi
    
    # Print summary (unless quiet)
    if ! $QUIET; then
        echo "Duration: ${SECONDS_LIMIT} seconds"
        if $boot_detected; then
            echo "Boot detected: YES"
        else
            echo "Boot detected: NO"
        fi
    fi
    
    # Exit based on boot detection
    if $boot_detected; then
        exit 0
    else
        if ! $QUIET; then
            echo "" >&2
            echo "WARNING: No boot output detected" >&2
            echo "The board may be stuck in download mode." >&2
            echo "Try: ./scripts/reset" >&2
        fi
        exit 1
    fi
}

main "$@"
