#!/usr/bin/env bash
# monitor - Serial monitor with file logging (works in interactive & non-interactive modes)
#
# Usage: ./scripts/monitor [OPTIONS]
#
# Options:
#   --port <path>      Serial port path (default: auto-detect)
#   --baud <rate>      Baud rate (default: 115200)
#   --timeout <sec>    Exit after N seconds (0 = never)
#   --no-log           Don't write to log file
#   --log-dir <path>   Log file directory (default: ./logs)
#   --force-pio        Force PlatformIO monitor (requires TTY)
#   --force-pyserial   Force pyserial monitor (works without TTY)
#
# Exit codes:
#   0 - Normal exit (Ctrl+C or timeout)
#   1 - Port error (permission denied, port busy)
#   2 - No serial monitor available
#
# Environment:
#   MONITOR_PORT     Override port
#   BAUD_RATE        Override baud rate
#   MONITOR_SECONDS  Override timeout
#   ESP_LOG_DIR      Override log directory

set -euo pipefail

# --- Configuration ---
VERSION="1.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# --- Globals ---
PORT=""
BAUD="${BAUD_RATE:-115200}"
TIMEOUT="${MONITOR_SECONDS:-0}"
LOG_ENABLED=true
LOG_DIR="${ESP_LOG_DIR:-./logs}"
FORCE_PIO=false
FORCE_PYSERIAL=false

# --- Functions ---

usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Serial monitor with file logging. Works in both interactive and non-interactive
environments (pipes, scripts, CI). Automatically uses pyserial when no TTY is
available, and PlatformIO when running interactively.

Options:
  --port <path>      Serial port path (default: auto-detect)
  --baud <rate>      Baud rate (default: 115200)
  --timeout <sec>    Exit after N seconds (0 = never, default: 0)
  --no-log           Don't write to log file
  --log-dir <path>   Log file directory (default: ./logs)
  --force-pio        Force PlatformIO monitor (requires TTY)
  --force-pyserial   Force pyserial monitor (works without TTY)
  -h, --help         Show this help message
  -v, --version      Show version

Exit codes:
  0 - Normal exit (Ctrl+C or timeout)
  1 - Port error (permission denied, port busy)
  2 - Serial monitor unavailable

Environment:
  MONITOR_PORT       Override port
  BAUD_RATE          Override baud rate
  MONITOR_SECONDS    Override timeout (equivalent to --timeout)
  ESP_LOG_DIR        Override log directory
EOF
}

# Get port from device-list
get_auto_port() {
    local device_list_script="$SCRIPT_DIR/device-list"
    
    if [[ -x "$device_list_script" ]]; then
        "$device_list_script" --first 2>/dev/null || echo ""
    else
        pio device list 2>/dev/null | grep -E '^/dev/' | head -1 || echo ""
    fi
}

# Run pyserial-based monitor (works without TTY)
# Arguments: port baud timeout log_file
run_pyserial_monitor() {
    local port="$1"
    local baud="$2"
    local timeout_sec="$3"
    local log_file="$4"
    
    python3 << PYEOF
import serial
import sys
import signal
import time

# Configuration from bash
PORT = "$port"
BAUD = $baud
TIMEOUT_SEC = $timeout_sec
LOG_FILE = "$log_file" if "$log_file" else None

# Global flag for clean shutdown
running = True

def signal_handler(sig, frame):
    global running
    running = False

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

def main():
    global running
    log_fh = None
    ser = None
    
    try:
        # Open log file if specified
        if LOG_FILE:
            log_fh = open(LOG_FILE, 'a', buffering=1)
        
        # Open serial port
        ser = serial.Serial(PORT, BAUD, timeout=0.1)
        
        start_time = time.time()
        
        while running:
            # Check timeout
            if TIMEOUT_SEC > 0:
                elapsed = time.time() - start_time
                if elapsed >= TIMEOUT_SEC:
                    break
            
            # Read available data
            try:
                if ser.in_waiting > 0:
                    data = ser.read(ser.in_waiting)
                else:
                    data = ser.read(1)  # Blocking read with timeout
                
                if data:
                    text = data.decode('utf-8', errors='replace')
                    sys.stdout.write(text)
                    sys.stdout.flush()
                    
                    if log_fh:
                        log_fh.write(text)
                        log_fh.flush()
            except serial.SerialException as e:
                print(f"\nSerial error: {e}", file=sys.stderr)
                return 1
                
    except serial.SerialException as e:
        print(f"Failed to open port: {e}", file=sys.stderr)
        return 1
    except KeyboardInterrupt:
        pass
    finally:
        if ser and ser.is_open:
            ser.close()
        if log_fh:
            log_fh.close()
    
    return 0

sys.exit(main())
PYEOF
}

# Main function
main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --port)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --port requires a path" >&2
                    exit 1
                fi
                PORT="$2"
                shift 2
                ;;
            --baud)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --baud requires a number" >&2
                    exit 1
                fi
                BAUD="$2"
                shift 2
                ;;
            --timeout)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --timeout requires a number" >&2
                    exit 1
                fi
                TIMEOUT="$2"
                shift 2
                ;;
            --no-log)
                LOG_ENABLED=false
                shift
                ;;
            --force-pio)
                FORCE_PIO=true
                shift
                ;;
            --force-pyserial)
                FORCE_PYSERIAL=true
                shift
                ;;
            --log-dir)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --log-dir requires a path" >&2
                    exit 1
                fi
                LOG_DIR="$2"
                shift 2
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                echo "monitor version $VERSION"
                exit 0
                ;;
            *)
                echo "Error: Unknown option: $1" >&2
                usage >&2
                exit 1
                ;;
        esac
    done
    
    # Get port (env override, then argument, then auto-detect)
    PORT="${MONITOR_PORT:-$PORT}"
    
    if [[ -z "$PORT" ]]; then
        PORT=$(get_auto_port)
    fi
    
    if [[ -z "$PORT" ]]; then
        echo "Error: No serial port found" >&2
        echo "Run: ./scripts/device-list" >&2
        exit 1
    fi
    
    # Verify port exists
    if [[ ! -e "$PORT" ]]; then
        echo "Error: Port $PORT does not exist" >&2
        exit 1
    fi
    
    # Check permissions
    if [[ ! -r "$PORT" || ! -w "$PORT" ]]; then
        echo "Error: Permission denied on $PORT" >&2
        echo "" >&2
        echo "FIX: Add yourself to dialout group:" >&2
        echo "  1. Enable: modules.hardware.espDevices.enable = true;" >&2
        echo "  2. Rebuild NixOS and logout/login" >&2
        exit 1
    fi
    
    # Setup logging
    local log_file=""
    if $LOG_ENABLED; then
        mkdir -p "$LOG_DIR"
        log_file="$LOG_DIR/serial-$(date +%Y%m%d-%H%M%S).log"
    fi
    
    # Print header
    echo "ESP32 Serial Monitor"
    echo "===================="
    echo "Port: $PORT"
    echo "Baud: $BAUD"
    if $LOG_ENABLED; then
        echo "Log: $log_file"
    fi
    if [[ "$TIMEOUT" -gt 0 ]]; then
        echo "Timeout: $TIMEOUT seconds"
    fi
    
    # Determine which monitor to use
    local monitor_cmd=""
    local has_tty=false
    
    # Check if we have a TTY
    if [[ -t 0 ]] && [[ -t 1 ]]; then
        has_tty=true
    fi
    
    # Determine monitor backend
    if $FORCE_PYSERIAL; then
        monitor_cmd="pyserial"
    elif $FORCE_PIO; then
        if ! $has_tty; then
            echo "Error: --force-pio requires an interactive terminal (TTY)" >&2
            echo "Remove --force-pio or run in an interactive shell" >&2
            exit 2
        fi
        monitor_cmd="pio"
    elif $has_tty && command -v pio &> /dev/null; then
        # Interactive mode: prefer pio for better experience
        monitor_cmd="pio"
    elif command -v python3 &> /dev/null && python3 -c "import serial" 2>/dev/null; then
        # Non-interactive or no pio: use pyserial
        monitor_cmd="pyserial"
    elif command -v picocom &> /dev/null && $has_tty; then
        # Fallback to picocom if interactive
        monitor_cmd="picocom"
    else
        echo "Error: No serial monitor available" >&2
        echo "" >&2
        echo "Install one of:" >&2
        echo "  - pyserial: pip install pyserial (works non-interactively)" >&2
        echo "  - platformio: pip install platformio (interactive only)" >&2
        echo "  - picocom: available in most package managers" >&2
        exit 2
    fi
    
    if ! $has_tty; then
        echo "Mode: non-interactive (using $monitor_cmd)"
    fi
    echo "Press Ctrl+C to stop"
    echo "---"
    
    # Build and run monitor command
    local exit_code=0
    
    if [[ "$monitor_cmd" == "pyserial" ]]; then
        # Python-based serial monitor (works without TTY)
        run_pyserial_monitor "$PORT" "$BAUD" "$TIMEOUT" "$log_file" || exit_code=$?
    elif [[ "$monitor_cmd" == "pio" ]]; then
        # PlatformIO device monitor
        local pio_args=(device monitor --port "$PORT" --baud "$BAUD" --raw)
        
        if [[ "$TIMEOUT" -gt 0 ]]; then
            if $LOG_ENABLED; then
                timeout "$TIMEOUT" pio "${pio_args[@]}" 2>&1 | tee -a "$log_file" || exit_code=$?
            else
                timeout "$TIMEOUT" pio "${pio_args[@]}" || exit_code=$?
            fi
        else
            if $LOG_ENABLED; then
                pio "${pio_args[@]}" 2>&1 | tee -a "$log_file" || exit_code=$?
            else
                pio "${pio_args[@]}" || exit_code=$?
            fi
        fi
    else
        # Picocom fallback
        local picocom_args=(-b "$BAUD" --noreset --noinit "$PORT")
        
        if [[ "$TIMEOUT" -gt 0 ]]; then
            if $LOG_ENABLED; then
                timeout "$TIMEOUT" picocom "${picocom_args[@]}" 2>&1 | tee -a "$log_file" || exit_code=$?
            else
                timeout "$TIMEOUT" picocom "${picocom_args[@]}" || exit_code=$?
            fi
        else
            if $LOG_ENABLED; then
                picocom "${picocom_args[@]}" 2>&1 | tee -a "$log_file" || exit_code=$?
            else
                picocom "${picocom_args[@]}" || exit_code=$?
            fi
        fi
    fi
    
    echo "---"
    
    # Handle exit
    if [[ "$TIMEOUT" -gt 0 ]] && [[ $exit_code -eq 124 ]]; then
        echo "Stopped: timeout after $TIMEOUT seconds"
        exit_code=0
    elif [[ $exit_code -eq 130 ]] || [[ $exit_code -eq 0 ]]; then
        echo "Stopped: user interrupt"
        exit_code=0
    fi
    
    if $LOG_ENABLED && [[ -f "$log_file" ]]; then
        local line_count
        line_count=$(wc -l < "$log_file" 2>/dev/null || echo 0)
        echo "Log saved: $log_file ($line_count lines)"
    fi
    
    exit $exit_code
}

main "$@"
