#!/usr/bin/env bash

set -euo pipefail

#######################################
# NixOS Switch - Streamlined Edition
# Modern TUI     # Validate host configuration with proper error handling  
    if ! gum spin --spinner dot --title "Validating host configuration..." -- \
        timeout 120s nix build "$FLAKE_DIR#nixosConfigurations.$host.config.system.build.toplevel" --dry-run &>/dev/null; then
        error "Host configuration validation failed for: $host"
        
        # Try to get more detailed error information
        if [[ "${NON_INTERACTIVE:-false}" != "true" ]] && gum confirm "Show detailed validation errors?"; then
            echo "Running validation with verbose output:"
            nix build "$FLAKE_DIR#nixosConfigurations.$host.config.system.build.toplevel" --dry-run 2>&1 | head -20
        fi
        return 1
    firallel processing and auto-host detection
# v7.0.0 - Complete rewrite focusing on performance and UX
#######################################

readonly SCRIPT_VERSION="7.0.0"
readonly FLAKE_DIR="$HOME/NixOS"
readonly LOG_DIR="$HOME/.cache/nixos-rebuild"

# Check dependencies
for cmd in gum nix git; do
    if ! command -v "$cmd" &>/dev/null; then
        echo "âŒ Missing required tool: $cmd"
        exit 1
    fi
done

#######################################
# Modern TUI Components
#######################################

show_banner() {
    gum style \
    --foreground 212 \
    --border-foreground 39 \
    --border thick \
    --align center \
    --width 70 \
    --margin "1 2" \
    --padding "2 4" \
    "ðŸš€ NixOS Switch v${SCRIPT_VERSION}" \
    "" \
    "âœ¨ Streamlined â€¢ Parallel â€¢ Beautiful âœ¨"
}

log_with_level() {
    local level="$1"
    local msg="$2"
    gum log --structured --level "$level" "$msg"
    [[ -n "${LOG_FILE:-}" ]] && echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $msg" >> "$LOG_FILE"
}

info() { log_with_level "info" "$1"; }
success() { log_with_level "info" "âœ… $1"; }
error() { log_with_level "error" "âŒ $1"; }
warn() { log_with_level "warn" "âš ï¸  $1"; }
warn() { log_with_level "warn" "âš ï¸  $1"; }

progress_group() {
    local title="$1"
    shift
    gum style --foreground 99 --bold "ðŸ“‹ $title"
    gum join --vertical "$@"
}

#######################################
# Core Functions
#######################################

detect_host() {
    case "$(hostname)" in
        *laptop*|*mobile*|nixos-laptop) echo "laptop" ;;
        *) echo "default" ;;
    esac
}

setup_logging() {
    mkdir -p "$LOG_DIR"
    LOG_FILE="$LOG_DIR/nixswitch-$(date '+%Y%m%d_%H%M%S').log"
    
    # Parallel cleanup of old logs
    {
        find "$LOG_DIR" -name "nixswitch-*.log" -type f | sort -r | tail -n +6 | xargs -r rm &
        find "$LOG_DIR" -name "nixswitch-*.log" -type f -mtime +3 -delete 2>/dev/null &
        sudo journalctl --vacuum-time=1week 2>/dev/null &
        wait
    } || true
    
    info "Logging setup complete"
}

parallel_updates() {
    local host="$1"
    info "Running parallel updates and validations..."
    
    # Create temp files for parallel processing
    local temp_dir=$(mktemp -d)
    trap "rm -rf $temp_dir" EXIT
    
    # Run git fetch, flake update, and basic checks in parallel using background jobs
    {
        (git -C "$FLAKE_DIR" fetch origin 2>/dev/null && echo "git_fetch_ok" > "$temp_dir/git_fetch" || echo "git_fetch_failed" > "$temp_dir/git_fetch") &
        (nix flake update "$FLAKE_DIR" 2>/dev/null && echo "flake_update_ok" > "$temp_dir/flake_update" || echo "flake_update_failed" > "$temp_dir/flake_update") &
        (nix flake check --no-build "$FLAKE_DIR" 2>/dev/null && echo "syntax_ok" > "$temp_dir/syntax_check" || echo "syntax_failed" > "$temp_dir/syntax_check") &
        (df /nix --output=avail --block-size=1G | tail -1 | tr -d ' ' > "$temp_dir/disk_space") &
        
        # Wait for all background jobs to complete
        wait
    }
    
    # Check results
    local disk_gb=$(cat "$temp_dir/disk_space" 2>/dev/null || echo "0")
    local git_result=$(cat "$temp_dir/git_fetch" 2>/dev/null || echo "git_fetch_failed")
    local flake_result=$(cat "$temp_dir/flake_update" 2>/dev/null || echo "flake_update_failed")
    local syntax_result=$(cat "$temp_dir/syntax_check" 2>/dev/null || echo "syntax_failed")
    
    # Display results with beautiful formatting
    progress_group "Update Results" \
    "$(if [[ "$git_result" == "git_fetch_ok" ]]; then echo "âœ… Git fetch"; else echo "âš ï¸  Git fetch (non-critical)"; fi)" \
    "$(if [[ "$flake_result" == "flake_update_ok" ]]; then echo "âœ… Flake update"; else echo "âŒ Flake update failed"; fi)" \
    "$(if [[ "$syntax_result" == "syntax_ok" ]]; then echo "âœ… Syntax check"; else echo "âŒ Syntax check failed"; fi)" \
    "$(if [[ "$disk_gb" -ge 5 ]]; then echo "âœ… Disk space: ${disk_gb}GB"; else echo "âš ï¸  Low disk space: ${disk_gb}GB"; fi)"
    
    # Fail if critical checks failed
    if [[ "$flake_result" == "flake_update_failed" ]]; then
        error "Flake update failed - this is critical"
        return 1
    fi
    
    if [[ "$syntax_result" == "syntax_failed" ]]; then
        error "Syntax validation failed - configuration is invalid"
        return 1
    fi
    
    [[ "$disk_gb" -lt 5 ]] && warn "Low disk space detected"
    
    # Validate host configuration with proper error handling
    if ! gum spin --spinner dot --title "Validating host configuration..." -- \
    timeout 30s nix build "$FLAKE_DIR#nixosConfigurations.$host.config.system.build.toplevel" --dry-run 2>/dev/null; then
        error "Host configuration validation failed for: $host"
        info "This might be due to syntax errors or missing dependencies"
        return 1
    fi
    
    success "All validations passed"
}

perform_rebuild() {
    local host="$1"
    
    # Enhanced password handling with better UX
    gum style \
    --foreground 214 \
    --border normal \
    --border-foreground 214 \
    --padding "1 2" \
    --margin "1 0" \
    "ðŸ” System Rebuild Authentication" \
    "" \
    "Sudo access required for system rebuild" \
    "Please enter your password when prompted"
    
    # Test sudo access first
    if ! sudo -v 2>/dev/null; then
        error "Authentication failed - cannot proceed with rebuild"
        return 1
    fi
    
    success "Authentication successful"
    
    # Keep sudo alive in background (improved)
    (
        while sleep 30; do
            sudo -v 2>/dev/null || break
        done
    ) &
    local sudo_pid=$!
    trap "kill $sudo_pid 2>/dev/null || true" EXIT
    
    # Format code if available (parallel with other tasks)
    if command -v alejandra &>/dev/null; then
        gum spin --spinner dot --title "Formatting code..." -- alejandra "$FLAKE_DIR" &>/dev/null &
        local format_pid=$!
    fi
    
    # Main rebuild with enhanced progress and timing
    local start_time=$(date +%s)
    
    info "Starting NixOS rebuild for host: $host"
    
    # Wait for formatting to complete if it was started
    [[ -n "${format_pid:-}" ]] && wait $format_pid && success "Code formatting completed"
    
    # Execute rebuild with better error handling
    local rebuild_cmd=(
        sudo nixos-rebuild switch
        --flake "$FLAKE_DIR#$host"
        --show-trace
    )
    
    if gum spin \
    --spinner globe \
    --title "Building and switching to new configuration..." \
    --show-output \
    -- "${rebuild_cmd[@]}" 2>&1 | tee -a "$LOG_FILE"; then
        
        local duration=$(( $(date +%s) - start_time ))
        success "Rebuild completed successfully in ${duration}s"
        
        # Show generation info in a nice format
        local current_gen=$(sudo nixos-rebuild list-generations | grep current | awk '{print $1}')
        gum style \
        --foreground 84 \
        --border normal \
        --border-foreground 84 \
        --padding "1 2" \
        "ðŸŽ¯ Active Configuration" \
        "" \
        "Generation: $current_gen" \
        "Host: $host" \
        "Build time: ${duration}s"
        
    else
        local duration=$(( $(date +%s) - start_time ))
        error "Rebuild failed after ${duration}s"
        
        if [[ "${NON_INTERACTIVE:-false}" != "true" ]] && gum confirm "View error logs?"; then
            tail -n 30 "$LOG_FILE" | gum pager
        fi
        return 1
    fi
    
    # Cleanup background processes
    kill $sudo_pid 2>/dev/null || true
}

parallel_cleanup() {
    info "Running parallel cleanup tasks..."
    
    # Create a progress display for cleanup tasks
    gum style --foreground 99 --bold "ðŸ§¹ System Cleanup in Progress"
    
    # Use GNU parallel if available, otherwise fall back to background jobs
    if command -v parallel &>/dev/null; then
        # Use GNU parallel for better job management
        parallel --will-cite --halt now,fail=1 --jobs 3 ::: \
        "nix-collect-garbage --delete-older-than 7d 2>/dev/null" \
        "nix store optimise 2>/dev/null" \
        "nix store gc 2>/dev/null" || warn "Some cleanup tasks failed"
    else
        # Fallback to background jobs
        {
            nix-collect-garbage --delete-older-than 7d 2>/dev/null &
            nix store optimise 2>/dev/null &
            nix store gc 2>/dev/null &
            wait
        } || warn "Some cleanup tasks failed"
    fi
    
    success "System cleanup completed"
}

git_workflow() {
    local host="$1"
    
    cd "$FLAKE_DIR"
    
    # Check if we have changes or unpushed commits
    local has_changes=false
    local has_unpushed=false
    
    if ! git diff --quiet || ! git diff --cached --quiet; then
        has_changes=true
    fi
    
    if git remote get-url origin &>/dev/null; then
        local unpushed=$(git rev-list --count origin..HEAD 2>/dev/null || echo "0")
        [[ "$unpushed" -gt 0 ]] && has_unpushed=true
    fi
    
    if [[ "$has_changes" == "false" && "$has_unpushed" == "false" ]]; then
        info "Git repository is clean and up to date"
        return 0
    fi
    
    gum style --foreground 214 --bold "ðŸ“ Git Workflow"
    
    # Handle uncommitted changes
    if [[ "$has_changes" == "true" ]]; then
        git status --porcelain | head -5 | gum table --border thick --header "Changed Files"
        
        if [[ "${NON_INTERACTIVE:-false}" != "true" ]] && ! gum confirm "Commit changes?"; then
            info "Skipping git commit"
            return 0
        fi
        
        local msg=${COMMIT_MESSAGE:-"nixos: automated update after successful rebuild"}
        git add -A && git commit -m "$msg"
        success "Changes committed"
        has_unpushed=true
    fi
    
    # Handle push
    if [[ "$has_unpushed" == "true" && "${NON_INTERACTIVE:-false}" != "true" ]]; then
        if gum confirm "Push commits to remote?"; then
            git push && success "Pushed to remote"
        fi
        elif [[ "$has_unpushed" == "true" && "${NON_INTERACTIVE:-false}" == "true" ]]; then
        git push && success "Auto-pushed to remote"
    fi
}

show_system_status() {
    local host="$1"
    
    # Create a beautiful system status display
    local sys_info=$(gum join --vertical \
        "Host: $host" \
        "Hostname: $(hostname)" \
        "Kernel: $(uname -r)" \
        "CPU Cores: $(nproc)" \
        "Memory: $(free -h | awk 'NR==2{print $2}')" \
        "Storage: $(df -h /nix | awk 'NR==2{print $4}') free"
    )
    
    gum style \
    --foreground 99 \
    --border normal \
    --border-foreground 39 \
    --padding "1 2" \
    --margin "1 0" \
    "ðŸ“Š System Status" \
    "" \
    "$sys_info"
}

#######################################
# Main Function
#######################################

main() {
    show_banner
    
    # Get host
    local host=${SPECIFIED_HOST:-$(detect_host)}
    gum style --foreground 212 --bold "ðŸŽ¯ Target Host: $host"
    
    # Change to flake directory
    if ! cd "$FLAKE_DIR" 2>/dev/null; then
        error "Cannot access flake directory: $FLAKE_DIR"
        exit 1
    fi
    
    # Setup logging
    setup_logging
    
    # Show system status
    show_system_status "$host"
    
    # Verify host configuration exists
    if [[ ! -d "hosts/$host" ]]; then
        error "Host configuration '$host' not found"
        info "Available hosts: $(ls hosts/ | tr '\n' ' ')"
        exit 1
    fi
    
    # Run parallel updates and validation
    if ! parallel_updates "$host"; then
        exit 1
    fi
    
    # Confirmation
    if [[ "${NON_INTERACTIVE:-false}" != "true" ]]; then
        gum confirm --default=true "Proceed with rebuild?" || {
            info "Cancelled by user"
            exit 0
        }
    fi
    
    # Main rebuild
    if ! perform_rebuild "$host"; then
        exit 1
    fi
    
    # Post-rebuild tasks in parallel
    {
        parallel_cleanup &
        git_workflow "$host" &
        wait
    }
    
    # Success celebration
    gum style \
    --foreground 84 \
    --border double \
    --border-foreground 84 \
    --align center \
    --width 60 \
    --margin "1 2" \
    --padding "2 4" \
    "ðŸŽ‰ SUCCESS! ðŸŽ‰" \
    "" \
    "NixOS rebuild completed successfully" \
    "Host: $host" \
    "Time: $(date '+%H:%M:%S')"
    
    # Optional log viewing
    if [[ "${NON_INTERACTIVE:-false}" != "true" ]] && gum confirm "View detailed logs?"; then
        gum pager < "$LOG_FILE"
    fi
}

show_help() {
    gum style --foreground 212 --bold "NixOS Switch v${SCRIPT_VERSION}"
    echo
    gum style --foreground 39 "Streamlined NixOS rebuild with modern TUI and parallel processing"
    echo
    gum table --border thick <<EOF
Option,Description
--help/-h,Show this help
--non-interactive/-y,Skip confirmations
--commit-message MSG,Custom commit message
default/laptop,Specify host (auto-detected if omitted)
EOF
    echo
    gum style --foreground 84 "Features: Auto-detection â€¢ Parallel processing â€¢ Beautiful TUI â€¢ Git integration"
}

# Command line parsing
NON_INTERACTIVE=false
COMMIT_MESSAGE=""
SPECIFIED_HOST=""

# Handle help first
for arg in "$@"; do
    if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
        show_help
        exit 0
    fi
done

while [[ $# -gt 0 ]]; do
    case $1 in
        -y|--non-interactive) NON_INTERACTIVE=true; shift ;;
        --commit-message) COMMIT_MESSAGE="$2"; shift 2 ;;
        default|laptop) SPECIFIED_HOST="$1"; shift ;;
        *) error "Unknown option: $1"; show_help; exit 1 ;;
    esac
done

main
